---
原文链接: https://cdn.openai.com/pdf/6a2631dc-783e-479b-b1a4-af0cfbd38630/how-openai-uses-codex.pdf
原文标题: How OpenAI Uses Codex
所属周次: Week 1
阅读时间: 20min
优先级: ⭐必读
翻译日期: 2026-02-03
---

# OpenAI 如何使用 Codex

**简介**

Codex 每天都在 OpenAI 的众多技术团队中使用，包括安全、产品工程、前端、API、基础设施和性能工程团队。团队使用它来加速一系列工程任务，从理解复杂系统和重构大型代码库，到交付新功能和在紧迫的期限内解决事故。

基于对 OpenAI 工程师的采访和内部使用数据，我们要汇编了用例和最佳实践，突出了 Codex 如何帮助我们的团队走得更快，提高工作质量，并在规模化中管理复杂性。

---

## 用例 1：代码理解

Codex 帮助我们的团队在入职、调试或调查事故时，快速熟悉代码库中不熟悉的部分。

他们经常使用 Codex 来定位功能的核心逻辑，梳理服务或模块之间的关系，并追踪系统中的数据流。它还有助于通过代码浮现架构模式或缺失的文档，否则这需要大量的手动工作来生成。

在事故响应期间，Codex 帮助工程师通过浮现组件之间的交互或追踪故障状态如何在系统中传播，从而快速进入新领域。

### 团队轶事

> "当我修复错误时，我使用 Ask 模式查看代码库中其他地方是否可能出现相同的问题，以便我可以快速分类。"
> —— 检索系统性能工程师

> "当我随叫随到（on-call）时，我粘贴堆栈跟踪并询问'我在哪里做这个？' Codex 回答这一认证流程在哪里。它跳转到正确文件的速度比 grep 快得多。"
> —— API 平台站点可靠性工程师

> "我向 Codex 询问有关 Terraform 和 Python 库的问题。"
> —— 基础设施服务 DevOps 工程师

### 尝试使用 Codex 进行代码理解
你可以使用以下示例提示：
- "这个 repo 中的认证逻辑是在哪里实现的？"
- "总结请求是如何从入口点到响应流经此服务的。"
- "哪些模块与 [插入模块名称] 交互，以及如何处理故障？"

---

## 用例 2：重构和迁移

Codex 通常用于进行跨越多个文件或包的更改。例如，当工程师正在更新 API，更改模式的实现方式，或迁移到新的依赖项时，Codex 使应用一致的更改变得容易。

当需要在几十个文件中进行相同的更新，或者当更新需要通过正则表达式或查找替换无法轻易捕获的结构和依赖项意识时，它特别有用。

他们还使用它通过分解过大的模块、用现代模式替换旧模式或为更好的可测试性准备代码来进行代码清理。

### 团队轶事

> "Codex 为我们的新服务模式替换了每个旧的 `getUserById()` 并打开了 PR。它在几分钟内完成了本来需要几个小时的工作。"
> —— ChatGPT Web 后端工程师

> "为了清除发布阻碍，我让 Codex 扫描每个旧模式的实例，用 Markdown 总结影响，然后用修复程序打开 PR。"
> —— ChatGPT Enterprise 产品工程师

### 尝试使用 Codex 进行重构和迁移
你可以使用以下示例提示：
- "按关注点将此文件拆分为单独的模块，并为每个模块生成测试。"
- "将所有基于回调的数据库访问转换为 async/await。"

---

## 用例 3：性能优化

Codex 用于识别和解决性能瓶颈。

在调优或可靠性工作期间，工程师提示 Codex 分析缓慢或内存密集的代码路径，例如低效的循环、冗余操作或昂贵的查询，并建议优化的替代方案，通常会在效率和可靠性方面带来有意义的收益。

Codex 还用于通过识别仍在活跃使用的风险或已弃用的模式来支持代码健康。我们的团队依靠它来帮助减少长期技术债务并主动防止回归。

### 团队轶事

> "我使用 Codex 扫描重复的昂贵 DB 调用。它非常擅长标记热路径并起草我以后可以调整的批处理查询。"
> —— API 可靠性基础设施工程师

> "Codex 非常适合快速发现性能问题——我花 5 分钟写提示，节省了 30 分钟的工作。"
> —— 模型服务平台工程师

### 尝试使用 Codex 进行性能优化
你可以使用以下示例提示：
- "优化此循环以提高内存效率，并解释为什么你的版本更快。"
- "在此请求处理程序中查找重复的昂贵操作并建议缓存机会。"
- "建议在此函数中批处理 DB 查询的更快方法。"

---

## 用例 4：提高测试覆盖率

Codex 帮助工程师更快地编写测试——尤其是在覆盖率薄弱或完全缺失的地方。

在处理错误修复或重构时，工程师经常要求 Codex 建议涵盖边缘情况或可能的故障路径的测试。对于新代码，它可以根据函数签名和周围逻辑生成单元测试或集成测试。

Codex 对于识别边界条件特别有帮助，例如空输入、最大长度或经常在初始测试中被遗漏的不寻常但有效的状态。

### 团队轶事

> "我在一夜之间将 Codex 指向低覆盖率模块，醒来时看到了可运行的单元测试 PR。"
> —— ChatGPT 桌面前端工程师

> "当切换 mono-repo 分支很痛苦时，我让 Codex 编写测试并启动 CI，而我继续在我的分支上工作。"
> —— 支付与计费后端工程师

### 尝试使用 Codex 提高测试覆盖率
你可以使用以下示例提示：
- "为此函数编写单元测试，包括边缘情况和故障路径。"
- "为此排序实用程序生成基于属性的测试。"
- "扩展此测试文件以覆盖围绕空输入和无效状态的缺失场景。"

---

## 用例 5：提高开发速度

Codex 通过加速开发周期的开始和结束来帮助团队更快地行动。

在启动新功能时，工程师使用它来搭建样板——生成文件夹、模块和 API存根，以便快速获得可运行的代码，而无需手动编写每一部分。

随着项目接近发布，Codex 通过处理更小但必不可少的任务（如分类错误、填补最后一公里的实施空白以及生成推出脚本、遥测钩子或配置文件）来帮助满足紧迫的最后期限。

它还用于将产品反馈转化为其起始代码。工程师经常粘贴用户请求或规范，并让 Codex 生成草稿，以便他们稍后返回并完善。

### 团队轶事

> "我整天都在开会，但仍然合并了 4 个 PR，因为 Codex 在后台工作。"
> —— ChatGPT Enterprise 产品工程师

> "Codex 帮助完美地交付了 3-4 个低优先级修复，否则这些修复会被搁置在积压工作中，这非常令人振奋。"
> —— 内部工具全栈工程师

### 尝试使用 Codex 提高开发速度
你可以使用以下示例提示：
- "使用基本验证和日志记录为 `POST /events` 搭建新的 API 路由。"
- "生成一个遥测钩子，用于跟踪新入职流程的成功/失败，使用此模板 [插入你的遥测代码示例]。"
- "基于此规范创建一个存根实现：[插入规范或产品反馈]。"

---

## 用例 6：保持心流 (Staying in flow)

Codex 帮助我们的工程师在日程安排分散且充满干扰时保持生产力。

它用于捕获未完成的工作，将笔记转化为工作原型，或剥离稍后可以重新访问的探索性任务。这使得暂停和恢复工作变得更加容易，而不会丢失上下文，尤其是在他们on-call或有很多会议时。

### 团队轶事

> "如果我发现一个顺手可修的修复，我会启动一个 Codex 任务，而不是切换分支，并在我有空时审查其 PR。"
> —— ChatGPT API 后端工程师

> "我经常将 Slack 线程、Datadog 跟踪、问题等转发给 Codex，以便我可以专注于高优先级工作。"
> —— 基础设施可观测性 API 工程师

### 尝试使用 Codex 保持心流
你可以使用以下示例提示：
- "生成重构此服务并将其拆分为更小模块的计划。"
- "通过存根 (stub out) 重试逻辑并添加 TODO —— 我稍后会填写回退逻辑。"
- "总结此文件，以便我明天可以从中断的地方继续。"

---

## 用例 7：探索和构思

Codex 对于开放式工作也很有用，例如寻找替代解决方案或验证设计决策。你可以提示解决问题的不同方法，探索不熟悉的模式，或压力测试假设。这有助于浮现权衡，扩展设计选项，并明确实施选择。

它还用于识别相关错误。给定一个已知问题或已弃用的方法，Codex 可以在代码中的其他位置识别类似的模式，从而更容易捕获回归或完成清理工作。

### 团队轶事

> "Codex 帮助我解决冷启动问题——我粘贴规范和文档，它会搭建代码或向我展示我忘记的内容。"
> —— ChatGPT 桌面产品工程师

> "在我修复一个错误后，我问 Codex 类似的错误可能潜伏在哪里，然后启动后续任务。"
> —— 检索系统性能工程师

### 尝试使用 Codex 进行探索和构思
你可以使用以下示例提示：
- "如果系统是事件驱动而不是请求/响应，这将如何工作？"
- "查找所有手动构建 SQL 字符串而不是使用我们的查询构建器的模块。"
- "以更函数式的风格重写此内容，避免突变和副作用。"

---

## 最佳实践

当给予 Codex 结构、上下文和迭达空间时，它的效果最好。以下是 OpenAI 团队正在培养的一些习惯，以便在日常工作中从中获得持续的价值。

1.  **从 Ask 模式开始**
    对于大型更改，首先使用 Ask 模式提示 Codex 获取实施计划，这随后成为你切换到 Code 模式时的后续提示的输入。这种两步流程使 Codex 保持脚踏实地，并有助于避免其输出中的错误。Codex 最适合处理范围明确的任务，这些任务通常需要你或队友大约一个小时才能完成，或者需要几百行代码来实现。随着模型的改进，预计它可以承担的任务规模将会增加。

2.  **迭代改进 Codex 的开发环境**
    设置启动脚本、环境变量和互联网访问权限可显着降低 Codex 的错误率。在运行任务时，寻找可以在 Codex 的环境配置中纠正的构建错误。这可能需要几次迭代，但从长远来看会带来显著的效率提升。

3.  **像编写 Github Issue 一样构建你的提示**
    当提示反映你在 PR 或 issue 中描述更改的方式时，Codex 的响应会更好。这意味着包括相关的路径、组件名称、diff 和文档片段。使用诸如"按照 [模块 X] 中的方式实现此操作"之类的模式进行提示可以改善结果。

4.  **将 Codex 任务队列用作轻量级 backlog**
    启动任务以捕获切线想法、部分工作或附带修复。没有压力要一次性生成完整的 PR。Codex 作为一个暂存区效果很好，你可以在重新集中注意力时返回该区域。

5.  **使用 `AGENTS.md` 提供持久上下文**
    维护一个 `AGENTS.md` 文件，以帮助 Codex 在跨提示的 repo 中更有效地运行。这些文件通常包括命名约定、业务逻辑、已知怪癖或 Codex 无法仅从代码中推断出的依赖项。在文档中了解有关构建 `AGENTS.md` 文件的更多信息。

6.  **利用 "Best of N" 提高输出**
    "Best-of-N" 功能允许你为单个任务同时生成多个响应，以快速探索多个解决方案并选择最佳解决方案。对于更复杂的任务，你可以审查几次迭代并组合不同响应的部分以获得更强的结果。

---

## 展望未来

Codex 仍处于研究预览阶段，但它已经对我们的构建方式产生了真正的影响，帮助我们走得更快，编写更好的代码，并承担起否则永远不会被优先考虑的工作。

我们要对其未来的潜力感到兴奋——随着我们的模型变得更好，Codex 更加深入地集成到我们的工作流程中，我们期待解锁使用它开发软件的更强大的方法。我们将继续分享我们沿途学到的东西。

---

## 关键术语

| 英文 | 中文 | 说明 |
|------|------|------|
| Codebase | 代码库 | 软件项目的完整源代码集合 |
| Incident | 事故/事件 | 生产环境中的故障或异常情况 |
| Refactoring | 重构 | 在不改变外部行为的情况下改进代码结构 |
| Migration | 迁移 | 将代码、数据或系统从一种环境/版本转移到另一种 |
| Scaffolding | 搭建/脚手架 | 快速生成项目或代码的基础结构 |
| Boilerplate | 样板代码 | 通用、重复但必要的代码 |
| Telemetry | 遥测 | 自动从无法访问的源收集和传输数据进行监控 |
| Stub | 存根 | 用于替代尚未实现组件的占位符代码 |
| Ideation | 构思 | 形成想法或概念的过程 |
| Regression | 回归 | 以前正常工作的功能在变更后出现故障 |
| Backlog | 积压工作/待办列表 | 尚未完成的工作任务列表 |
