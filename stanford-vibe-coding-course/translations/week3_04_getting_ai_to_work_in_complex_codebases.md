---
原文链接: https://github.com/humanlayer/advanced-context-engineering-for-coding-agents/blob/main/ace-fca.md
原文标题: Getting AI to Work in Complex Codebases
所属周次: Week 3
阅读时间: 20min
优先级: ⭐必读
翻译日期: 2026-02-03
---

# 在复杂代码库中让 AI 工作 (Getting AI to Work in Complex Codebases)

**来源**: HumanLayer - Advanced Context Engineering (ace-fca)
**作者**: Loïc Lefloch (推测)

众所周知，AI 编码工具在真实的生产代码库中表现挣扎。[斯坦福关于 AI 对开发者生产力影响的研究](https://www.youtube.com/watch?v=tbDDYKRFjhk)发现：
1. AI 工具交付的许多“额外代码”最终只是在返工上周交付的垃圾代码。
2. 编码 Agent 对于新项目或小更改非常棒，但在大型成熟代码库中，它们往往会让开发者效率**降低**。

经过几个月的修补，我发现**如果你拥抱核心的上下文工程原则，即使是当今的模型也能走得很远**。
我们已经让 Claude Code 能够处理 30 万行 Rust 代码库，并在一天内交付一周的工作量，同时保持通过专家审查的代码质量。我们使用的一系列技术称为 **"频繁的有意压缩 (Frequent Intentional Compaction)"**。

## 编码 Agent 的高级上下文工程

### 1. 管理 Agent 上下文的“天真”方式
大多数人开始使用编码 Agent 就像使用聊天机器人一样。你与它来回对话（或“醉酒般地大喊大叫”），靠直觉（Vibing）解决问题，直到上下文耗尽、你放弃或者 Agent 开始道歉。

一种稍微聪明一点的方法是当你偏离轨道时重新开始，丢弃你的会话并开始一个新的，也许在 Prompt 中多加一点引导。

### 2.稍微聪明一点：有意压缩 (Intentional Compaction)
你可能做过我称之为“有意压缩”的事情。无论你是否在轨道上，当你的上下文开始填满时，你可能想暂停工作并用一个新的上下文窗口重新开始。为此，你可能会使用这样的 Prompt：

> "将我们目前所做的一切写入 `progress.md`，确保注明最终目标、我们采取的方法、目前已完成的步骤以及我们正在处理的当前故障。"

你也可以[使用提交信息进行有意压缩](https://x.com/dexhorthy/status/1961490837017088051)。

**我们到底在压缩什么？**
什么吃掉了上下文？
*   搜索文件
*   理解代码流
*   应用编辑
*   测试/构建日志
*   来自工具的巨大 JSON Blob

所有这些都会淹没上下文窗口。**压缩**仅仅是将它们提炼成结构化的工件。

### 3. 更有效的方法：频繁的有意压缩 (Frequent Intentional Compaction)
我们在过去几个月中采用的技术属于“频繁的有意压缩”。
从本质上讲，这意味着**围绕上下文管理设计你的整个工作流**，并将利用率保持在 40%-60% 的范围内（取决于问题的复杂性）。

我们的做法是将其分为三个（大约）步骤：

#### 1. 研究 (Research)
理解代码库、与问题相关的文件、信息如何流动，以及问题的潜在原因。
（此时我们会生成一份详细的研究文档）

#### 2. 计划 (Plan)
概述我们将采取的修复问题的确切步骤，我们需要编辑的文件以及如何编辑，对每个阶段的测试/验证步骤要非常精确。
（此时我们会生成一份详细的计划文档）

#### 3. 实施 (Implement)
逐步执行计划，逐个阶段进行。对于复杂的工作，我通常会在每个实施阶段通过验证后，将当前状态**压缩**回原始计划文件中。

### 实践案例
我与 @vaibhav 做了一个每周一次的直播编码会议。我们尝试在一个用于 LLM 编程语言 BAML 的 30 万行 Rust 代码库中修复一个 Bug。
- **研究**: 我创建了一份研究，Claude 认为 Bug 无效。我扔掉了那份研究，并在更多引导下开始了新的研究。
- **计划**: 在研究进行时，我不耐烦地启动了一个没有研究的计划。当研究完成后，我启动了另一个利用研究结果的实施计划。
- **结果**: 建立在研究基础上的计划在**最佳**位置修复了问题，并规定了符合代码库惯例的测试。

我们不仅修复了 Bug，后来还花费 7 小时（3 小时研究/计划，4 小时实施）交付了 3.5 万行代码来为 BAML 添加取消和 WASM 支持。Vaibhav 估计，这通常需要 BAML 团队的高级工程师花费 3-5 天才能完成。

**结论**: 通过频繁的有意压缩，我们可以在复杂代码库中解决复杂问题，且没有垃圾代码，保持心理一致性。

---

## 关键术语

| 英文 | 中文 | 说明 |
|------|------|------|
| Frequent Intentional Compaction | 频繁有意压缩 | 定期将上下文提炼成结构化文档以释放窗口空间的技术 |
| Context Engineering | 上下文工程 | 优化输入给模型的信息结构以提升性能的实践 |
| Slop | 垃圾/劣质代码 | AI 生成的质量低劣、甚至无法运行的代码 |
| Progress Artifact | 进度工件 | 记录当前状态、目标和下一步的文档（如 progress.md） |
